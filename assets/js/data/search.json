[ { "title": "Chroma Viz", "url": "/posts/chroma-viz/", "categories": "Software Development, Broadcast Graphics", "tags": "opengl, golang, chroma viz", "date": "2024-02-08 13:00:00 +1100", "snippet": "IntroductionThe aim of this project is to develop a collection of applications which can render custom graphics.Inspiration is taken from the VizRT suite of applications.Currently this collections consists of Chroma Viz, Chroma Engine, and Chroma Hub with the source code for each available on GitHub.Chroma VizChroma Viz is the front end for Chroma Engine.It provides a UI to view the templates contained in Chroma Hub.Pages can then be created from templates, which expose a number of attributes that can be changed using the editor page.Pages form shows, which can be imported or exported to a text file.Pages are displayed using Chroma Engine.Chroma Viz connects to Chroma Engine over a tcp socket, which can be configured in either program.Chroma Viz encodes the attributes changed by the user into a string and sends it to Chroma Engine.Chroma Engine parses this string and combines the data with the template from the graphics hub to display the graphicChroma EngineChroma Engine renders graphics requests from Chroma Viz.Chroma Engine has two modes: engine and preview.In engine mode, Chroma Engine launches a standalone gtk window to render graphics.This is a placeholder for what would be a process that communicates with a hardware graphics card to output graphics.In preview mode, Chroma Engine recieves an xorg window id and uses gtk plugs to embed a window with Chroma Viz while still running as a standalone instance.This allows the operator to view graphics in a preview window within Chroma Viz.Chroma Engine renders graphics using OpenGL.To render a graphic, first Chroma Engine recieves a string of data from a Chroma Viz instance.A simple name-attribute format name=attr# is sufficient for our purposes.The string contains a header with the format version, layer, template id, and action.Then each geometry, specified by an integer, followed by a list of attributes for the geometry.As we parse the string, we set the values for each geometry of the target template.Chroma HubThe purpose of Chroma Hub is to synchronize the graphic templates used by Chroma Viz and Chroma Engine instances.It also provides a single point to update or add a template.Chroma Hub is implemented in Golang and contains a database of templates and their geometries.Internally we use the encoding/json Golang package for simplicity to write and read a json format of the database to a file.Chroma Hub communicates with Chroma Engine and Chroma Viz instances over tcp socket connections.Chroma Hub listens to port 9000 by default (or as specified) for connections and sends the graphics hub as a string.Chroma Viz and Chroma Engine can set the Chroma Hub address individually and connect on startup, reading and parsing the data sent by Chroma Hub.Chroma Hub encodes the templates using a json-like format, which is restricted to simplify implementation on the Chroma Engine/Chroma Viz side.The format is described by the following Context Free Grammar (see Quaternion Calculator for a description of CFGs).\\[\\begin{align}S &amp;amp;\\to \\{ \\texttt{N, &#39;templates&#39;: [$T$]} \\} \\\\T &amp;amp;\\to \\{ \\texttt{N, &#39;geometry&#39;: [$G$]} \\} \\mid T, T \\\\G &amp;amp;\\to \\{ \\texttt{N, &#39;attr&#39;: [$A$]} \\} \\mid G, G \\\\A &amp;amp;\\to \\{ \\texttt{N} \\} \\mid A, A \\\\N &amp;amp;\\to \\texttt{&#39;%s&#39;: &#39;%s&#39;} \\mid \\texttt{&#39;%s&#39;: %d} \\mid N, N\\end{align}\\]where %s and %d are the corresponding strings and integers respectively.The non-terminals $ T, G, A $ represent a templates, geometries, and attributes respectively.The list of attributes for each non terminal is generated by the non terminal $ N $.On the Chroma Engine/Viz side we begin by tokenizing the string recieved.We have strings which begin with an ‘, integers and the special characters {, }, [, ], : and ,.While the grammar specified above is left-recursive and ambiguous, it is relatively simple to parse.Consider the following example production, which has the same form as $ T, G, A $ as above,\\(A \\to \\beta \\mid A, A\\).To eliminate left recursion and the amibiguity of this production, we replace this production with\\(A \\to \\beta, A \\mid \\beta\\).This new production is unambiguous and not left recursive.For simplicity in specifying the grammar we use the former.Now the grammar is unambiguous and not left-recursive, we can use a type of recursive-descent parsing known as predictive parsing.In Chroma Engine, this parser is contained in /src/parser/parser_recieve_hub.c, in Chroma Viz it is contained in /viz/parser.go.Chroma ArtistIn Progress: Chroma Artist provides a front end to design and export templates which can be imported to Chroma Hub." }, { "title": "Oscillating Curves on Triangulated 3-Manifolds", "url": "/posts/honours-thesis/", "categories": "Topology, Knot Theory", "tags": "oscillating curves, symplectic basis", "date": "2023-10-20 12:00:00 +1100", "snippet": "Honours Thesis This browser does not support PDF! " }, { "title": "Flight Simulator", "url": "/posts/flight-sim/", "categories": "Game Development", "tags": "game dev, curves, geometry", "date": "2022-12-10 12:00:00 +1100", "snippet": "The aim of this project is to develop a flight simulator controlled using torsion and curvature.It is built in python using the panda3D graphics library.DownloadThe game can be downloaded from jchilds0/flight-sim/releases. Download the latestarhive corresponding to your system, extract the archive and run ‘flight-sim.exe’.The source code can be viewed at jchilds0/flight-simPreliminariesA curve $ \\gamma $ is a map from $ \\mathbb{R} $ to $ \\mathbb{R}^3 $. We assume the curveis unit speed to simplify the formulas, $ |\\gamma’(s)| = 1 $. Then define the tangentvector $ T $ by $ T(s) = \\gamma’(s) $. Similarily define the normal vector $ N $, as the unitvector in the direction of $ T’(s) $. Finally define $ B(s) $ as the unit vector inthe direction of $ T(s) \\times N(s) $, where $ \\times $ is the cross product in$ \\mathbb{R}^3 $. Finally the curvature $ \\kappa $ at a point $ \\gamma(s) $ is definedas the length of T’(s), $ \\kappa(s) = |T’(s)| $. And the torsion $ \\tau $ at a point$ \\gamma(s) $ is defined $ - N(s) \\cdot B’(s) $, where $ \\cdot $ is the dot product.The triple $(T(s), N(s), B(s))$ is called the Frenet-Serre Frame and forms an orthogonalbasis for $ \\mathbb{R}^3 $. The quantities also satisfy a system of differential equationcalled the Frenet-Serre Formulas\\[T&#39;(s) = \\kappa N(s)\\]\\[N&#39;(s) = - \\kappa T(s) + \\tau B(s)\\]\\[B&#39;(s) = - \\tau N(s)\\]MechanicsWe start with an initial position $ \\gamma(0) $, $T(0) = (0, 1, 0)$, $N(0) = (1, 0, 0)$,$B(0) = (0, 0, 1)$. Then we add the formula $ \\gamma’(s) = T(s) $ to the Frenet-SerreFormulas, and solving this system numerically we obtain the next position. We also solvefurther ahead to draw a curve on the screen for the user, showing them the current curve they are on.InterpretationCurvature can be thought of as how much a curve curves, a curve with constant curvatureis a circle of radius $ 1 / \\kappa $. Torsion measures how much $ \\gamma $ is twisting outof the ‘osculating plane’. A curve with torsion 0 is contained in a plane." }, { "title": "Data Visualisation 2 - Adelie Penguins", "url": "/posts/data-visualisation-2/", "categories": "Data Visualisation", "tags": "data visualisation, adelie penguins, penguins, palmer station", "date": "2022-10-19 00:00:00 +1100", "snippet": "Webpage created for Monash - FIT3179 Data Visualisation, Data Visualisation 2 Assignment. Viewing on desktop isrecommended as the page is not formatted for mobile viewingRepository - FIT3179-Data-Visualisation-2Webpage - FIT3179-Data-Visualisation-2 " }, { "title": "Data Visualisation 1 - Formula 1", "url": "/posts/data-visualisation-1/", "categories": "Data Visualisation", "tags": "data visualisation, formula 1, racing", "date": "2022-09-09 00:00:00 +1000", "snippet": "Webpage created for Monash - FIT3179 Data Visualisation, Data Visualisation 1 Assignment. Viewing on desktop isrecommended as the page is not formatted for mobile viewing &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;" }, { "title": "Holomorphic Dynamics and Mobius Transformations", "url": "/posts/complex-analysis/", "categories": "Complex Analysis, Holomorphic Dynamics and Möbius Transformations", "tags": "möbius transformations, algebraic semigroups", "date": "2022-06-14 10:00:00 +1000", "snippet": "MTH3000 Final Report - Additional videos shown below report. This browser does not support PDF! ExampleLet $\\varphi : \\mathbb{D} \\mapsto \\mathbb{D}$ be defined by\\[\\varphi(z) = iz\\]$\\varphi$ is elliptic since it has one fixed point in $\\mathbb{D}$.ExampleLet $\\varphi : \\mathbb{H} \\mapsto \\mathbb{H}$ be defined by\\[\\varphi(z) = 2z\\]$\\varphi$ is parabolic since $(\\text{tr} \\varphi)^2 = 9$.ExampleLet $\\tau = 1$ and $\\alpha = 1$. Iterating $\\varphi_t$, on theupper half plane the points are translated along horoballs at the fixedpoint, moving away from one side of the fixed point towards the other.Let $\\tau = i$ and $\\alpha = 1$. Iterating $\\varphi_t$, on the upperhalf plane the points are translated along horoballs at the fixed point.Since the fixed point is at $\\infty$, the horoballs are horizontallines, so the points are simply translated in the plane.ExampleLet $\\tau = 0.5$ and $\\omega = \\frac{\\pi}{2}$. Iterating $\\varphi_t$,the points orbit around the fixed point, $0.5$.ExampleLet $\\sigma = 1$, $\\tau = i$ and $\\alpha = 1$. Iterating $\\varphi_t$,the points move away from one fixed points towards the other alonggeodesics, similarly to the behaviour of Hyperbolic MöbiustransformationsLet $\\sigma = 1$, $\\tau = -1$ and $\\alpha = 1$." }, { "title": "Quaternion Calculator", "url": "/posts/quaternions/", "categories": "Language Theory", "tags": "regular languages, context free languages, quaternions", "date": "2022-01-18 21:30:00 +1100", "snippet": "IntroductionThe aim of this project is to construct a quaternion calculator using flex and yacc. Flex is a lexical analyzer thatuses regular expressions. We use flex to match the elements of our language, quaternions, and pass these tokens to yacc.Yacc, Yet Another Compiler Compiler, parses context free grammars. We use yacc to evaluate the expression matched by flex.LanguagesWe start with a set of characters $\\sum$, which we call the alphabet. Then the set of all string concatenations isdenoted as $\\sum^*$, the universal language. A language is a subset of $\\sum^*$.Regular LanguagesA language, $L$, is regular if it can be matched by a regular expression. We define a regular expression inductively asfollows,If $r \\in L$, then $r$ is a regular expression (the empty string $\\varepsilon$ and the empty set $\\emptyset$ are alsoregular expressions)Let $R, Q$ be regular expressions, then $R \\cup Q$, which means $R$ or $Q$ $(R)$ $R^*$, the Kleene star, which means $R$ concatenated with itself an arbitrary number of times $RQ$, which means the concatenation of $R$ and $Q$ are regular expressions. For example, any finite language is regular as listing out all elements of the languageseparated by the or operator $\\cup$ is a regular expression for the language.Another example, let’s use the alphabet ${ a, b}$ and the regular expression $(aa \\cup bb)^*$. The empty string ismatched by this regular expression as we can concatenate $(aa \\cup bb)$ 0 times. The string bbbbaa is matched by theregular expression as we can concatenate $(aa \\cup bb)$ 3 times, pick bb on the first two and aa in the last one.Context Free LanguagesA language, $L$, is context free if it can be generated by a context free grammar. A context free grammar consists ofproduction rules over a the alphabet and another set called the non terminals. The elements of the alphabet are calledthe terminals and usually denoted as lowercase, while terminals are usually denoted as uppercase. A production ruleconsists of a nonterminal on the LHS which produces the string of terminals and non terminals on the RHS, for example\\[X \\to aXY\\]To generate a string, we start with the nonterminal $S$ and finish when there are no more non terminals. For example,the language even-even over the alphabet ${a,b}$, which can be denoted by the set${ a^n b^n \\ | \\ n \\in \\mathbb{N} }$, is generated by the context free grammar,\\[\\begin{align}S &amp;amp;\\to ASB \\tag{1} \\\\S &amp;amp;\\to \\varepsilon \\tag {2} \\\\A &amp;amp;\\to a \\tag{3} \\\\B &amp;amp;\\to b \\tag{4}\\end{align}\\]We can generate aabb as follows, starting with the non terminal S\\(\\begin{align*}S &amp;amp;\\to ASB \\tag{Rule 1} \\\\ &amp;amp;\\to AASBB \\tag{Rule 1} \\\\ &amp;amp;\\to AA\\varepsilon BB \\tag{Rule 2} \\\\ &amp;amp;\\to aabb \\tag{Rule 3, 4}\\end{align*}\\)It turns out this language cannot be generated by any regular expression.QuaternionsA quaternion is a number of the form\\(w + x \\mathbf{i} + y \\mathbf{j} + z \\mathbf{k}\\)where $w,x,y,z \\in \\mathbb{R}$ and $\\mathbf{i},\\mathbf{j},\\mathbf{k}$ are thequaternion units, satisfying\\[\\begin{align*}\\mathbf{i}^2 &amp;amp;= -1 \\\\\\mathbf{j}^2 &amp;amp;= -1 \\\\\\mathbf{k}^2 &amp;amp;= -1 \\\\\\mathbf{i}\\mathbf{j}\\mathbf{k} &amp;amp;= -1\\end{align*}\\]The quaternions can be constructed rigorously using Clifford Algebras, but that is beyond the scope of this project.Along with the usual operations of addition, subtraction, multiplication and division, we also have the operation ofrotation. Rotation(r, q)*p/Rotation(r,q) represents a rotation of the point p around the axis of rotation given by qby r radians.\\[\\text{Rotation}(r, q) = \\cos(r/2) + \\sin(r/2) \\hat{q}\\]where $\\hat{q}$ is the unit vector in the direction of $q$. It is not obvious that Rotation($r,q$) has this effecton $p$, this lesson by Grant Sanderson gives an explanation and intuition behind this formula.Visualizing QuaternionsNow we make precise what a quaternion expression is with the following inductive definition, $\\mathbf{i},\\mathbf{j},\\mathbf{k}$ are quaternion expression If $r$ is a real number, then $r$, $r\\mathbf{i}$,$r\\mathbf{j}$, $r\\mathbf{k}$ are quaternion expressions If $p$ and $q$ are quaternion expressions, then so are: $(q)$, $-q$, $p + q$,$p-q$, $p*q$, $p/q$ If $q$ is a quaternion expression and $n$ is an natural number, then $q^n$ is a quaternionexpression. If $r$ is a NUMBER and $q$ is a quaternion expression, then Rotation($r,q$) isa quaternion expression.FlexNow that we have regular expressions and context free grammars, we build the flex file to recognize the elements of thelanguage quaternion. We will only consider numbers in their finite decimal representations or integers.The following regular expression matches any non negative integer,(0|[1-9][0-9]*)and the corresponding language recognized by the expression as WHOLENUMBER. The following regular expression matches any non negative number in a finite decimal representation([1-9][0-9]*\\.[0-9][0-9]*|0\\.[0-9][0-9]*)and the corresponding language recognized by the expression as NUMBER. These two expressions along with a rule for operations and one for whitespace make up the flex file. For example the rule for NUMBER is as follows,([1-9][0-9]*\\.[0-9][0-9]*|0\\.[0-9][0-9]*) {/* printf(&quot;Token: NUMBER; Lexeme: %s\\n&quot;, yytext);*/ yylval.num = atof(yytext); return NUMBER; }YaccConverting the inductive definition for the langage QUATERNION of quaternion expressions to a context free grammarover the alphabet \\(\\{ \\mathbf{i}, \\mathbf{j}, \\mathbf{k}, +, −, ∗, /, ˆ, (, ), \\text{NUMBER}, \\text{WHOLENUMBER},\\text{ROTATION}, \\mathbf{,} \\}\\),\\[\\begin{align*}S &amp;amp;\\rightarrow Q \\\\Q &amp;amp;\\rightarrow (Q) \\ | -Q \\ | \\ Q + Q \\ | \\ Q - Q \\ | \\ Q * Q \\ | \\ Q \\backslash Q \\\\Q &amp;amp;\\rightarrow Q \\text{^WHOLENUMER} \\ | \\ \\text{ROTATION} (R, Q) \\\\Q &amp;amp;\\rightarrow R \\ | \\ E \\ | \\ R E \\\\R &amp;amp;\\rightarrow \\text{WHOLENUMBER} \\ | \\ \\text{NUMBER} \\\\E &amp;amp;\\rightarrow \\mathbf{i} \\ | \\ \\mathbf{j} \\ | \\ \\mathbf{k}\\end{align*}\\]These are then used in the rules section of the yacc file to parse the file, taking the form,\\(\\it{pattern} \\qquad \\{ \\ \\ \\ \\it{action} \\ \\ \\ \\}\\)For example the rule $Q \\to Q + Q$ becomes the rule,expr : expr &#39;+&#39; expr { $$ = sum($1, $3); }sum is a C function defined later in the yacc file as,Quaternion sum(Quaternion q1, Quaternion q2)/* returns the sum q1 + q2 of the quaternions q1 and q2. This may be viewed as just a vector sum.*/{ Quaternion qsum; qsum.w = q1.w + q2.w; qsum.x = q1.x + q2.x; qsum.y = q1.y + q2.y; qsum.z = q1.z + q2.z; return qsum;}Repeating this for the other production rules we obtain a rudimentary calculator.ExtensionThe calculator works for simple operations, but there are a few issues. It can’t handle exponents that are quaternionexpressions, the sqrt, log and exp functions are not defined, the return function prints zeros and +- instead of just -.There is also a computational error with juxtaposition, (3k)^2 is parsed as 3k^2.We begin by making the return statements cleaner, we modify the simple print statementreturn printf(&quot;%f + %f i + %f j + %f k\\n&quot;, q.w, q.x, q.y, q.z);to include if statements that check if the number is non zero, include a + or - sign depending on the parity of thenumber, and include the + sign if there are non zero number that occur before it. The final function is long,but the outputs are cleaner.To fix the issue with juxtaposition, we replace the naive $Q \\to Q\\text{^WHOLENUMBER}$ production rule with the following setof rules,power : &#39;(&#39; expr &#39;)&#39; &#39;^&#39; expr { $$ = QuatPower($2,$5); } | real imag &#39;^&#39; expr { $$ = scalarTimesQuaternion($1, QuatPower($2,$4)); } | imag &#39;^&#39; expr { $$ = QuatPower($1,$3); } | real &#39;^&#39; expr { $$ = QuatPower(newQuaternion($1, 0, 0, 0), $3); } ;Now for functions power, log, exp. To calculate the exponential, we use the Taylor Series for the exponential function.$q = w + x \\mathbf{i} + y \\mathbf{j} + z \\mathbf{k} = w + \\mathbf{v}$,\\[\\begin{align}e^q = e^{w + \\mathbf{v}} &amp;amp;= e^w \\sum_{n = 0}^{\\infty} \\frac{\\mathbf{v}^n}{n!} \\\\&amp;amp;= e^w \\bigg( \\sum_{n = 0}^{\\infty} \\frac{\\mathbf{v}^{2n}}{(2n)!} + \\frac{\\mathbf{v}^{2n+1}}{(2n+1)! }\\bigg) \\\\&amp;amp;= e^w \\bigg( \\sum_{n = 0}^{\\infty} \\frac{||\\mathbf{v}||^{2n} \\hat{\\mathbf{v}}^{2n}}{(2n)!} + \\frac{||\\mathbf{v}||^{2n + 1}\\hat{\\mathbf{v}}^{2n+1}}{(2n + 1)! }\\bigg) \\\\&amp;amp;= e^w \\bigg( \\sum_{n = 0}^{\\infty} \\frac{(-1)^n ||\\mathbf{v}||^{2n}}{(2n)!} + \\frac{\\mathbf{v}}{||\\mathbf{v}||}\\frac{(-1)^n||\\mathbf{v}||^{2n + 1}}{(2n + 1)! }\\bigg) \\\\&amp;amp;= e^w \\bigg( \\cos||\\mathbf{v}|| + \\frac{\\mathbf{v}}{||\\mathbf{v}||} \\sin||\\mathbf{v}|| \\bigg)\\end{align}\\]Then we use the C math functions to calculate each of these quantities.Quaternion QuatExp(Quaternion p)/* returns e^p. */{ if (norm(imaginaryPart(p)) == 0){ return newQuaternion(exp(p.w), 0, 0, 0); } return scalarTimesQuaternion(exp(p.w), sum(newQuaternion(cos(norm(imaginaryPart(p))), 0, 0, 0), scalarTimesQuaternion(sin(norm(imaginaryPart(p))), unitQuaternion(imaginaryPart(p)))));}Deriving the formula for the quaternion logarithm, let $w = s + \\mathbf{v}$, where $s \\in \\mathbb{R}$ and $\\mathbf{v}$is a purely imaginary quaternion.\\[\\ln(w) = \\ln||w|| + \\ln \\bigg(\\frac{s + \\mathbf{v}}{||w||} \\bigg)\\]Let $\\theta \\in \\mathbb{R}$ and $\\mathbf{u}$ be a purely imaginary unit quaternion, using the exponential formula above,\\[e^{\\theta \\mathbf{u}} = \\cos(\\theta) + \\mathbf{u} \\sin(\\theta)\\]Therefore by definition,\\[\\ln(\\cos(\\theta) + \\mathbf{u} \\sin(\\theta)) = \\theta \\mathbf{u}\\]Substituting $\\theta = \\arccos(\\frac{s}{||w||})$,\\[\\ln \\bigg( \\frac{s}{||w||} + \\sqrt{1 - \\frac{s^2}{||w||^2}} \\mathbf{u} \\bigg) =\\mathbf{u} \\arccos \\bigg(\\frac{s}{||w||} \\bigg)\\]Using Pythagoras’ Theorem,\\[||w|| = ||s + \\mathbf{v}|| \\Rightarrow ||w||^2 - s^2 = ||v||^2\\]\\[\\ln \\bigg( \\frac{s + ||\\mathbf{v}|| \\mathbf{u}}{||w||} \\bigg) = \\mathbf{u} \\arccos \\bigg(\\frac{s}{||w||} \\bigg)\\]Substituting $\\mathbf{u} = \\frac{\\mathbf{v}}{||\\mathbf{v}||}$, which is valid as $\\mathbf{v}$ is a purelyimaginary quaternion,\\[\\ln \\bigg( \\frac{s + \\mathbf{v}}{||w||} \\bigg) =\\frac{\\mathbf{v}}{||\\mathbf{v}||} \\arccos \\bigg(\\frac{s}{||w||} \\bigg)\\]Therefore,\\[\\ln(w) = \\ln||w|| + \\frac{\\mathbf{v}}{||\\mathbf{v}||} \\arccos \\bigg(\\frac{s}{||w||} \\bigg)\\]The argument of the logarithm and inverse cosine are real so we can use C math functions to evaluate this formula,Quaternion QuatLog(Quaternion p)/* returns log(p). */{ if (norm(imaginaryPart(p)) == 0){ return newQuaternion(log(p.w), 0, 0, 0); } return sum(newQuaternion(log(norm(p)), 0, 0, 0), scalarTimesQuaternion(acos(p.w / norm(p)), unitQuaternion(imaginaryPart(p))));}Finally we can use the logarithm and exponential functions to calculate powers of quaternions. By definition,\\[p^q = (e^{\\ln(p)})^q = e^{q \\ln(p)}\\]where $p \\neq 0$.Quaternion QuatPower(Quaternion p, Quaternion q)/* returns p^q. */{ if (norm(p) == 0){ if (norm(q) == 0){ return newQuaternion(1,0,0,0); } else{ return newQuaternion(0,0,0,0); } } return QuatExp(product(q, QuatLog(p)));}To evaluate these expressions, we add rules to the lex file to recognize the functions,(Log|Ln|log|ln) {/* printf(&quot;Token: LOG; Lexeme: %s\\n&quot;, yytext);*/ yylval.str = strdup(yytext); return LOG; }This means we only need to write one production rule in the yacc file, and the calculator will recognize any of theabove forms,expr : LOG &#39;(&#39; expr &#39;)&#39; { $$ = QuatLog($3); }If you would like to try out the calculator, an exe is available here Quat" }, { "title": "Integral of Even Powers of Cosine", "url": "/posts/EulerIdentity/", "categories": "Complex Analysis", "tags": "euler, contour", "date": "2022-01-07 15:00:00 +1100", "snippet": "Let $n \\in \\mathbb{N}$.\\[I_n := \\int_0^{2\\pi} \\cos^{2n} (\\theta) d\\theta = 2 \\pi \\frac{1 \\cdot 3 \\cdot 5 \\cdot \\cdot \\cdot (2n -1)}{2 \\cdot 4 \\cdot 6 \\cdot \\cdot \\cdot (2n)}\\]We begin by relating $I_n$ to the following integral\\[J_n := \\int_{\\{|z| = 1\\}} \\bigg( z + \\frac{1}{z} \\bigg)^{2n} \\frac{dz}{z}\\]Using Euler’s Identity $e^{i \\theta} = \\cos(\\theta) + i\\sin(\\theta)$, we can rewrite$\\cos(\\theta)$,\\[\\cos(\\theta) = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}\\]\\[I_n = \\int_0^{2\\pi} \\bigg(\\frac{e^{i\\theta} + e^{-i\\theta}}{2} \\bigg)^{2n} d\\theta\\]making the substitution $z = e^{i \\theta}$ to the integral $I_n$, the interval 0 to $2\\pi$ becomes the unit circle,\\[dz = i e^{i\\theta} d\\theta\\]\\[\\Rightarrow \\int_{\\{|z| = 1\\}} \\bigg( \\frac{z + z^{-1}}{2} \\bigg)^{2n} \\frac{dz}{iz}\\]\\[= \\frac{-i}{2^{2n}} \\int_{\\{|z| = 1\\}} \\bigg( z + \\frac{1}{z} \\bigg)^{2n} \\frac{dz}{z}\\]\\[I_n = \\frac{-i}{2^{2n}} J_n\\]In order to evaluate this integral, we convert it to a form to apply the Cauchy’s Theorem, namely\\[\\int_{\\{|z| = 1\\}} \\frac{f(z)}{(z-z_0)^{2n+1}} dz\\]For an appropriate $z_0 \\in \\mathbb{C}$ and an appropriate analytic function $f(z)$.\\[J_n = \\int_{\\{|z| = 1\\}} \\bigg( z + \\frac{1}{z} \\bigg)^{2n} \\frac{dz}{z}\\]\\[= \\int_{\\{|z| = 1\\}} \\frac{(z^2 + 1)^{2n}}{z^{2n}} \\frac{dz}{z}\\]\\[= \\int_{\\{|z| = 1\\}} \\frac{(z^2 + 1)^{2n}}{z^{2n+1}} dz\\]Therefore $z_0 = 0$ and $f(z) = (z^2+1)^{2n}$. The Cauchy Integral Formula is given by,\\[f(z_0) = \\frac{1}{2i\\pi} \\int_C \\frac{f(z)}{z-z_0} dz\\]where $f(z)$ is an analytic function, $C$ is a positively oriented simple closed curve and $z_0$ any point inside thedomain bounded by $C$.Differentiating n times with respect to $z_0$\\[f^{(n)}(z_0) = \\frac{n!}{2i\\pi} \\int_C \\frac{f(z)}{(z-z_0)^{n+1}} dz\\] Rearranging for the integral on the RHS, redefining $n:=2n$ and letting $C$ be the curve $ z = 1$, \\[f^{(2n)}(z_0) \\frac{2i\\pi}{(2n)!} = \\int_{\\{|z| = 1\\}} \\frac{f(z)}{(z-z_0)^{2n+1}} dz\\]Putting together the above pieces we obtain the value of $I_n$.Let $f(z) = (z^2+1)^{2n}$ (which is entire as f is a polynomial), $z_0 = 0$, and substitute into the above formula, the RHS becomes the integral $J_n$,\\[J_n = \\frac{2i\\pi}{(2n)!} f^{(2n)}(0)\\]Using the binomial expansion formula, we can expand $f(z)$\\[f(z) = \\sum_{m=0}^{2n} \\frac{(2n)!}{m!(2n-m)!} z^{2m}\\]To substitute f into the following equation,\\[J_n = \\frac{2i\\pi}{(2n)!} f^{(2n)}(0)\\]we need to differentiate $f(z)$ $2n$ times, and then set $z = 0$. As a result allterms vanish except when $m = n$. The $m = n$ term is given by,\\[\\frac{(2n)!}{(n!)^2} z^{2n}\\]Differentiating the expresion above $2n$ times and substituting into $f^{(2n)}(0)$ gives,\\[f^{(2n)}(0) = \\bigg( \\frac{(2n)!}{n!} \\bigg)^2\\]Therefore,\\[J_n = \\frac{2\\pi i (2n)!}{(n!)^2}\\]Substituting $J_n$ into the equation we found at the start relating $I_n$ to $J_n$,\\[I_n = \\frac{-i}{2^{2n}} J_n\\]\\[= 2 \\pi \\frac{(2n)!}{2^{2n}(n!)^2}\\]\\[= 2 \\pi \\frac{(2n)!}{2^nn!} \\frac{1}{2^nn!}\\]The first fraction can be rewritten as $(2n-1)!!$ where !! represents the double factorial, the product of all oddnumbers up to $2n-1$. The $2^n$ term halves all of the even numbers in the $(2n)!$ term to give $n!$ which is thencancelled out by the $n!$ in the denominator and we are left with all of the odd numbers up to $2n$ or more precisely$2n-1$. The second fraction becomes $(2n)!!$, the product of all even numbers up to $2n$ as we multiple each term in$n!$ by 2.\\[\\Rightarrow I_n = 2 \\pi \\frac{(2n-1)!!}{(2n)!!} = 2 \\pi \\frac{1 \\cdot 3 \\cdot 5 \\cdot \\cdot \\cdot (2n -1)}{2 \\cdot 4 \\cdot 6 \\cdot \\cdot \\cdot (2n)}\\]" } ]
