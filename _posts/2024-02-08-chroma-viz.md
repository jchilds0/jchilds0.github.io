---
title: Chroma Viz
date: 2024-02-08 13:00
categories: [Software Development, Broadcast Graphics]
tags: [opengl, golang, chroma viz]     # TAG names should always be lowercase
math: true
comments: false
---

**Introduction**

The aim of this project is to develop a collection of applications which can render custom graphics.
Inspiration is taken from the VizRT suite of applications.
Currently this collections consists of [Chroma Viz](https://github.com/jchilds0/chroma-viz), [Chroma Engine](https://github.com/jchilds0/chroma-engine), and [Chroma Hub](https://github.com/jchilds0/chroma-hub) with the source code for each available on GitHub.

<img src="/assets/chroma-viz.png" alt="Chroma Viz">

<img src="/assets/chroma-engine.png" alt="Chroma Engine">

**Chroma Viz**

Chroma Viz is the front end for Chroma Engine.
It provides a UI to view the templates contained in Chroma Hub.
Pages can then be created from templates, which expose a number of attributes that can be changed using the editor page.
Pages form shows, which can be imported or exported to a text file.
Pages are displayed using Chroma Engine.
Chroma Viz connects to Chroma Engine over a tcp socket, which can be configured in either program.
Chroma Viz encodes the attributes changed by the user into a string and sends it to Chroma Engine.
Chroma Engine parses this string and combines the data with the template from the graphics hub to display the graphic

**Chroma Engine**

Chroma Engine renders graphics requests from Chroma Viz.
Chroma Engine has two modes: engine and preview.
In engine mode, Chroma Engine launches a standalone gtk window to render graphics.
This is a placeholder for what would be a process that communicates with a hardware graphics card to output graphics.
In preview mode, Chroma Engine recieves an xorg window id and uses gtk plugs to embed a window with Chroma Viz while still running as a standalone instance.
This allows the operator to view graphics in a preview window within Chroma Viz.

Chroma Engine renders graphics using OpenGL.
To render a graphic, first Chroma Engine recieves a string of data from a Chroma Viz instance.
A simple name-attribute format `name=attr#` is sufficient for our purposes.
The string contains a header with the format version, layer, template id, and action.
Then each geometry, specified by an integer, followed by a list of attributes for the geometry.
As we parse the string, we set the values for each geometry of the target template.

**Chroma Hub**

The purpose of Chroma Hub is to synchronize the graphic templates used by Chroma Viz and Chroma Engine instances.
It also provides a single point to update or add a template.
Chroma Hub is implemented in Golang and contains a database of templates and their geometries.
Internally we use the `encoding/json` Golang package for simplicity to write and read a json format of the database to a file.
Chroma Hub communicates with Chroma Engine and Chroma Viz instances over tcp socket connections.
Chroma Hub listens to port 9000 by default (or as specified) for connections and sends the graphics hub as a string.
Chroma Viz and Chroma Engine can set the Chroma Hub address individually and connect on startup, reading and parsing the data sent by Chroma Hub.

Chroma Hub encodes the templates using a json-like format, which is restricted to simplify implementation on the Chroma Engine/Chroma Viz side.
The format is described by the following Context Free Grammar (see Quaternion Calculator for a description of CFGs).

$$ \begin{align}
S &\to \{ \texttt{N, 'templates': [$T$]} \} \\
T &\to \{ \texttt{N, 'geometry': [$G$]} \} \mid T, T \\
G &\to \{ \texttt{N, 'attr': [$A$]} \} \mid G, G \\
A &\to \{ \texttt{N} \} \mid A, A \\
N &\to \texttt{'%s': '%s'} \mid \texttt{'%s': %d} \mid N, N
\end{align}$$

where %s and %d are the corresponding strings and integers respectively.
The non-terminals $ T, G, A $ represent a templates, geometries, and attributes respectively.
The list of attributes for each non terminal is generated by the non terminal $ N $.

On the Chroma Engine/Viz side we begin by tokenizing the string recieved.
We have strings which begin with an ', integers and the special characters {, }, [, ], : and ,.
While the grammar specified above is left-recursive and ambiguous, it is relatively simple to parse.
Consider the following example production, which has the same form as $ T, G, A $ as above,

$$ A \to \beta \mid A, A $$.

To eliminate left recursion and the amibiguity of this production, we replace this production with

$$ A \to \beta, A \mid \beta $$.

This new production is unambiguous and not left recursive.
For simplicity in specifying the grammar we use the former.
Now the grammar is unambiguous and not left-recursive, we can use a type of recursive-descent parsing known as predictive parsing.
In Chroma Engine, this parser is contained in `/src/parser/parser_recieve_hub.c`, in Chroma Viz it is contained in `/viz/parser.go`.

**Chroma Artist**

In Progress: Chroma Artist provides a front end to design and export templates which can be imported to Chroma Hub.
